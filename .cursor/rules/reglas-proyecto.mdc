# Reglas del Proyecto OCOBO-BACK

## Estándares de Código

- Seguir PSR-12 (PHP Coding Standards)
- Usar Laravel Pint antes de commits
- Indentación: 4 espacios (NO tabs)
- Líneas: Máximo 120 caracteres
- SIEMPRE usar type hints en parámetros y return types en métodos públicos

## Estructura Modular

El proyecto está organizado por módulos funcionales:
- `app/Http/Controllers/{Modulo}/` - Controladores
- `app/Http/Requests/{Modulo}/` - Form Requests
- `app/Models/{Modulo}/` - Modelos
- `database/seeders/{Modulo}/` - Seeders

## Convenciones de Nomenclatura

- Clases: PascalCase (UserController, StoreUserRequest)
- Métodos: camelCase (getUser, createRadicacion)
- Variables: camelCase ($userId, $configVarias)
- Tablas BD: snake_case plural (users, config_varias)
- Columnas BD: snake_case (num_radicado, fecha_documento)
- Rutas: kebab-case (/api/control-acceso/users)

## Arquitectura de Controladores

TODOS los controladores deben:
1. Extender Controller
2. Usar ApiResponseTrait para respuestas estandarizadas
3. Usar Form Requests para validaciones
4. Usar transacciones de BD cuando sea necesario

Ejemplo:
```php
use App\Http\Controllers\Controller;
use App\Http\Traits\ApiResponseTrait;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\DB;

class UserController extends Controller
{
    use ApiResponseTrait;

    public function store(StoreUserRequest $request): JsonResponse
    {
        try {
            DB::beginTransaction();
            // Lógica
            DB::commit();
            return $this->successResponse($user, 'Usuario creado exitosamente', 201);
        } catch (\Exception $e) {
            DB::rollBack();
            return $this->errorResponse('Error al crear el usuario', $e->getMessage(), 500);
        }
    }
}
```

## APIs y Respuestas

TODAS las respuestas JSON deben usar ApiResponseTrait:
- Éxito: `return $this->successResponse($data, 'Mensaje', 201);`
- Error: `return $this->errorResponse('Mensaje', $error, 500);`

Formato de respuesta:
```json
{
    "status": true/false,
    "message": "Mensaje descriptivo",
    "data": { ... }
}
```

Códigos HTTP: 200, 201, 400, 401, 403, 404, 422, 500

## Base de Datos

- SIEMPRE usar transacciones para operaciones críticas o múltiples tablas
- SIEMPRE usar eager loading para evitar N+1 queries: `User::with('roles', 'cargo')->get()`
- Usar select() para limitar columnas cuando sea necesario
- Paginar listados grandes

## Optimizaciones de Rendimiento y Consultas

### Consultas Optimizadas

**1. Select Específico en Consultas Principales**
```php
// ✅ CORRECTO: Solo campos necesarios
VentanillaRadicaReci::whereIn('id', $idsRadicados)
    ->select(['id', 'archivo_digital', 'uploaded_by', 'usuario_crea', 'updated_at', 'created_at'])
    ->with([...])

// ❌ INCORRECTO: Carga todos los campos
VentanillaRadicaReci::whereIn('id', $idsRadicados)->with([...])
```

**2. Select Específico en Eager Loading**
```php
// ✅ CORRECTO: Especificar columnas en relaciones
->with([
    'usuario:id,nombres,apellidos,email',
    'archivos:id,radicado_id,archivo,created_at',
    'responsables:id,radica_reci_id,users_cargos_id,custodio,fechor_visto,created_at',
])

// ❌ INCORRECTO: Cargar todas las columnas
->with(['usuario', 'archivos', 'responsables'])
```

**3. Evitar Conversiones Innecesarias**
```php
// ✅ CORRECTO: Laravel acepta colecciones en whereIn
$idsRadicados = $radicados->pluck('id');
Model::whereIn('id', $idsRadicados)

// ❌ INCORRECTO: Conversión a array innecesaria
$idsRadicados = $radicados->pluck('id')->toArray();
Model::whereIn('id', $idsRadicados)
```

**4. Verificación de Colecciones**
```php
// ✅ CORRECTO: Usar método específico de colecciones
if ($idsRadicados->isNotEmpty()) { ... }

// ❌ INCORRECTO: Verificación genérica
if (!empty($idsRadicados)) { ... }
```

### Optimización de Relaciones

**1. Verificar Relaciones Cargadas**
```php
// ✅ CORRECTO: Verificar antes de acceder
$archivosRelacion = $this->relationLoaded('archivos') 
    ? $this->archivos 
    : $this->archivos()->get();
```

**2. Cache de Relaciones**
```php
// ✅ CORRECTO: Cachear si se usa múltiples veces
$usuarioSubio = $this->getInfoUsuarioSubio();
// Usar $usuarioSubio en múltiples lugares

// ❌ INCORRECTO: Llamar múltiples veces
$info['subido_por'] = $this->getInfoUsuarioSubio()['nombre_completo'];
$info['usuario_subio'] = $this->getInfoUsuarioSubio();
```

### Optimización de Collections

**1. Evitar Múltiples Iteraciones**
```php
// ✅ CORRECTO: Una sola iteración con procesamiento directo
$items = collect();
foreach ($relacion as $item) {
    $info = $item->getInfo();
    if ($info) {
        $items->push($info);
    }
}

// ❌ INCORRECTO: Múltiples iteraciones
$items = $relacion->map(...)->filter()->values();
```

**2. Cálculos Durante Iteración**
```php
// ✅ CORRECTO: Calcular totales durante la iteración
$totalCustodios = 0;
foreach ($responsables as $responsable) {
    if ($responsable->custodio) {
        $totalCustodios++;
    }
}

// ❌ INCORRECTO: Iteración adicional para contar
$totalCustodios = $responsables->where('custodio', true)->count();
```

### Optimización de Vistas SQL

**1. Usar JOINs en lugar de Subconsultas Correlacionadas**
```sql
-- ✅ CORRECTO: LEFT JOIN con agregación
LEFT JOIN (
    SELECT radicado_id, COUNT(*) as total
    FROM ventanilla_radica_reci_archivos 
    GROUP BY radicado_id
) archivos_count ON archivos_count.radicado_id = vrr.id

-- ❌ INCORRECTO: Subconsulta correlacionada (O(n²))
(SELECT COUNT(*) FROM ventanilla_radica_reci_archivos WHERE radicado_id = vrr.id) as total_archivos
```

**2. Usar Totales de Vistas SQL**
```php
// ✅ CORRECTO: Usar totales calculados en la vista
$totalResponsables = $radicado->total_responsables ?? null;
$informacion = $radicado->getInformacionCompleta($totalResponsables);

// ❌ INCORRECTO: Recalcular totales innecesariamente
$totalResponsables = $responsables->count();
```

### Optimización de Archivos

**1. Cache de Instancias Storage**
```php
// ✅ CORRECTO: Usar ArchivoHelper con cache interno
ArchivoHelper::obtenerUrl($path, $disk);

// ❌ INCORRECTO: Crear instancia Storage en cada llamada
Storage::disk($disk)->url($path);
```

**2. Evitar Accesos al Filesystem Innecesarios**
```php
// ✅ CORRECTO: Metadatos solo cuando se solicitan
$info = $modelo->getInfoArchivo('campo', 'disk', $incluirMetadatos = false);

// ❌ INCORRECTO: Acceder al filesystem siempre
$info['tamaño'] = Storage::disk($disk)->size($path);
```

### Índices en Base de Datos

**SIEMPRE agregar índices para:**
- Claves foráneas: `idx_tabla_fk_id`
- Campos usados en WHERE frecuentes
- Campos usados en JOINs
- Campos compuestos usados en búsquedas: `idx_tabla_campo1_campo2`

```sql
-- ✅ CORRECTO: Índices para optimizar consultas
CREATE INDEX idx_vrr_archivos_radicado_id ON ventanilla_radica_reci_archivos(radicado_id);
CREATE INDEX idx_vrr_responsa_radicado_custodio ON ventanilla_radica_reci_responsa(radica_reci_id, custodio);
```

### Checklist de Optimización

Al escribir código que procesa múltiples registros, verificar:
- [ ] ¿Se usa `select()` para limitar columnas?
- [ ] ¿Se especifican columnas en `with()`?
- [ ] ¿Se verifica si las relaciones están cargadas antes de acceder?
- [ ] ¿Se cachean resultados que se usan múltiples veces?
- [ ] ¿Se evitan múltiples iteraciones sobre las mismas colecciones?
- [ ] ¿Se usan índices en campos de búsqueda/filtrado?
- [ ] ¿Se evitan conversiones innecesarias (toArray, etc)?
- [ ] ¿Se usan totales de vistas SQL en lugar de recalcular?
- [ ] ¿Se evitan accesos al filesystem en loops?

## Validaciones

TODAS las validaciones deben estar en Form Request classes:
- Ubicación: `app/Http/Requests/{Modulo}/`
- Nombres: PascalCase con sufijo Request (StoreUserRequest.php)
- Incluir métodos: authorize(), rules(), messages(), attributes()

Reglas comunes:
- Nombres: `required|string|max:70`
- Email: `required|email|unique:table,column|max:70`
- Contraseñas: `required|min:6|confirmed`
- Fechas: `required|date|date_format:Y-m-d`
- Archivos: `nullable|file|mimes:pdf,doc,docx|max:10240`

## Rutas

REGLA CRÍTICA: Rutas específicas ANTES de apiResource

```php
Route::middleware('auth:sanctum')->group(function () {
    Route::prefix('recurso')->name('modulo.recurso.')->group(function () {
        // Rutas específicas ANTES del resource
        Route::get('/estadisticas', [Controller::class, 'estadisticas'])->name('estadisticas');
        
        // Resource route DESPUÉS
        Route::apiResource('', Controller::class)
            ->parameters(['' => 'recurso'])
            ->names([...])
            ->except('create', 'edit');
    });
});
```

Organización:
- `routes/api.php` - Autenticación
- `routes/controlAcceso.php` - Control de acceso
- `routes/configuracion.php` - Configuración
- `routes/calidad.php` - Calidad
- `routes/clasifica_documental.php` - Clasificación documental
- `routes/ventanilla.php` - Ventanilla única
- `routes/gestion.php` - Gestión

Prefijos configurados en RouteServiceProvider:
- /api/control-acceso
- /api/config
- /api/calidad
- /api/clasifica-documental
- /api/ventanilla
- /api/gestion

## Documentación

TODOS los métodos públicos deben tener PHPDoc completo con:
- Descripción del método
- @param para cada parámetro
- @return con tipo de retorno
- @queryParam para parámetros de consulta
- @response con ejemplos de respuesta

## Seguridad

- TODAS las rutas protegidas deben usar `auth:sanctum`
- SIEMPRE validar entrada con Form Requests
- NUNCA confiar en datos del cliente
- SIEMPRE usar Eloquent o Query Builder (parametrizado)
- NUNCA concatenar strings para queries SQL
- Validar tipo MIME y tamaño de archivos

## Manejo de Errores

SIEMPRE usar try-catch en métodos que:
- Acceden a base de datos
- Procesan archivos
- Realizan operaciones que pueden fallar

Siempre incluir DB::rollBack() en el catch si se inició una transacción.

## Git y Commits

Usar Conventional Commits:
- `feat:` Nueva funcionalidad
- `fix:` Corrección de bug
- `docs:` Documentación
- `style:` Formato de código
- `refactor:` Refactorización
- `test:` Tests
- `chore:` Tareas de mantenimiento

## Checklist para Nuevas Funcionalidades

Al agregar nueva funcionalidad, verificar:
- [ ] Controlador creado en el módulo correcto
- [ ] Form Request creado para validaciones
- [ ] Modelo creado con relaciones y scopes necesarios
- [ ] Migración creada con timestamps apropiados
- [ ] Rutas definidas en archivo de rutas del módulo
- [ ] Rutas específicas ANTES de apiResource
- [ ] Uso de ApiResponseTrait en controlador
- [ ] Transacciones de BD cuando sea necesario
- [ ] PHPDoc completo en métodos públicos
- [ ] Eager loading en consultas
- [ ] Manejo de errores con try-catch
- [ ] Middleware de autenticación aplicado
- [ ] Tests creados (si aplica)

## Helpers Personalizados

- ArchivoHelper: Para gestión de archivos (app/Helpers/ArchivoHelper.php)

## Comandos Útiles

```bash
php artisan optimize:clear          # Limpiar cachés
php artisan route:list              # Ver rutas
php artisan pint                    # Aplicar PSR-12
composer dump-autoload              # Regenerar autoloader
php artisan migrate                 # Ejecutar migraciones
php artisan db:seed                 # Ejecutar seeders
php artisan test                    # Ejecutar tests
```

## Referencias

- Laravel 10.x Documentation
- PSR-12 Coding Standard
- Spatie Laravel-Permission
- Laravel Sanctum
